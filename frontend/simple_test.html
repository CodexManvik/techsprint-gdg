<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Posture Test</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; text-align: center; }
        .container { position: relative; width: 640px; height: 480px; margin: 20px auto; border: 3px solid #333; }
        #input_video { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        .metrics { margin: 20px; padding: 20px; background: #2d2d2d; border-radius: 8px; }
        .metric { margin: 10px 0; font-size: 18px; }
        .status { margin: 10px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>ü§ñ Simple Posture Test</h1>
    <div class="status" id="status">Initializing...</div>
    
    <div class="container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>
    </div>
    
    <div class="metrics">
        <div class="metric">üëÄ Eye Contact: <span id="eye-score">--</span></div>
        <div class="metric">üìê Shoulder: <span id="shoulder-score">--</span></div>
        <div class="metric">üßç Slouch: <span id="slouch-score">--</span></div>
        <div class="metric">ü§û Arms: <span id="arms-score">--</span></div>
        <hr style="border-color: #555; margin: 15px 0;">
        <div style="color: #FF6B6B; font-weight: bold;">üñêÔ∏è GESTURE ANALYSIS (NEW!)</div>
        <div class="metric">üëã Hands Visible: <span id="hands-visible">--</span></div>
        <div class="metric">üò∞ Face Touch: <span id="face-touch">--</span></div>
        <div class="metric">üé≠ Gestures: <span id="gestures">--</span></div>
        <div class="metric">üìä Activity: <span id="activity-level">--</span></div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        let currentLandmarks = null;
        let currentPoseLandmarks = null;
        
        // Your posture analysis variables
        let shoulderHistory = [];
        let baselineNoseShoulderDist = null;
        let armsCrossedHistory = [];
        
        // NEW: Gesture analysis variables
        let gestureSessionStart = Date.now();
        let totalFaceTouches = 0;
        let totalGestures = 0;
        let leftHandHistory = [];
        let rightHandHistory = [];
        let gestureTimestamps = [];
        
        // Gesture analysis thresholds
        const FACE_TOUCH_THRESHOLD = 0.1;
        const GESTURE_HEIGHT_THRESHOLD = 0.1;
        const GESTURE_VELOCITY_THRESHOLD = 0.02;
        
        function onFaceResults(results) {
            // Face mesh results handled in holistic
        }
        
        function onHolisticResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            // Store face landmarks
            if (results.faceLandmarks) {
                currentLandmarks = results.faceLandmarks;
                
                // Draw face mesh
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
                
                // Eye contact calculation
                const leftInner = results.faceLandmarks[33];
                const leftOuter = results.faceLandmarks[133];
                const eyeWidth = Math.abs(leftInner.x - leftOuter.x);
                const leftIris = results.faceLandmarks[468] || leftInner;
                const eyeCenterDist = Math.abs(leftIris.x - ((leftInner.x + leftOuter.x) / 2));
                const eyeContact = Math.max(0, 1.0 - (eyeCenterDist / eyeWidth)).toFixed(2);
                document.getElementById('eye-score').innerText = eyeContact;
            }
            
            // Draw pose skeleton and analyze posture
            if (results.poseLandmarks) {
                currentPoseLandmarks = results.poseLandmarks;
                
                // Draw pose skeleton
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                
                // Draw key points
                const keyPoints = [0, 11, 12, 15, 16, 23, 24];
                keyPoints.forEach(i => {
                    if (results.poseLandmarks[i] && results.poseLandmarks[i].visibility > 0.5) {
                        const lm = results.poseLandmarks[i];
                        let color = '#00FF00';
                        let radius = 5;
                        
                        if (i === 0) { color = '#FF0000'; radius = 6; }  // Nose
                        if (i === 11 || i === 12) { color = '#FFFF00'; radius = 6; }  // Shoulders
                        if (i === 15 || i === 16) { color = '#FF00FF'; radius = 6; }  // Wrists
                        if (i === 23 || i === 24) { color = '#00FFFF'; radius = 5; }  // Hips
                        
                        canvasCtx.fillStyle = color;
                        canvasCtx.beginPath();
                        canvasCtx.arc(lm.x * canvasElement.width, lm.y * canvasElement.height, radius, 0, 2 * Math.PI);
                        canvasCtx.fill();
                        
                        canvasCtx.strokeStyle = '#FFFFFF';
                        canvasCtx.lineWidth = 2;
                        canvasCtx.stroke();
                    }
                });
                
                // YOUR POSTURE ANALYSIS
                const postureMetrics = analyzePosture(results.poseLandmarks);
                updatePostureUI(postureMetrics);
            }
            
            // NEW: Draw hand landmarks if available
            if (results.leftHandLandmarks) {
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#FF00FF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.leftHandLandmarks, {color: '#FF00FF', radius: 3});
            }
            
            if (results.rightHandLandmarks) {
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.rightHandLandmarks, {color: '#00FFFF', radius: 3});
            }
            
            // NEW: Analyze hand gestures
            const gestureMetrics = analyzeGestures(
                results.leftHandLandmarks,
                results.rightHandLandmarks,
                results.faceLandmarks ? results.faceLandmarks[1] : null, // Nose landmark
                results.poseLandmarks ? (results.poseLandmarks[11].y + results.poseLandmarks[12].y) / 2 : 0.5
            );
            updateGestureUI(gestureMetrics);
            
            // Update status
            let statusParts = [];
            if (results.faceLandmarks) statusParts.push("Face");
            if (results.poseLandmarks) statusParts.push("Pose");
            if (results.leftHandLandmarks) statusParts.push("L-Hand");
            if (results.rightHandLandmarks) statusParts.push("R-Hand");
            
            if (statusParts.length > 0) {
                document.getElementById('status').innerText = `‚úÖ Tracking: ${statusParts.join(', ')}`;
            } else {
                document.getElementById('status').innerText = "‚ö†Ô∏è No detection - step back";
            }
            
            canvasCtx.restore();
        }
        
        // YOUR POSTURE ANALYSIS FUNCTION
        function analyzePosture(poseLandmarks) {
            if (!poseLandmarks || poseLandmarks.length < 33) {
                return null;
            }
            
            const nose = poseLandmarks[0];
            const leftShoulder = poseLandmarks[11];
            const rightShoulder = poseLandmarks[12];
            const leftWrist = poseLandmarks[15];
            const rightWrist = poseLandmarks[16];
            const leftHip = poseLandmarks[23];
            const rightHip = poseLandmarks[24];
            
            // 1. Shoulder angle
            const dx = rightShoulder.x - leftShoulder.x;
            const dy = rightShoulder.y - leftShoulder.y;
            let shoulderAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            if (shoulderAngle > 90) shoulderAngle = 180 - shoulderAngle;
            else if (shoulderAngle < -90) shoulderAngle = -180 - shoulderAngle;
            
            const isLeaning = Math.abs(shoulderAngle) > 15.0;
            
            // 2. Slouch detection
            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
            const shoulderAvgY = (leftShoulder.y + rightShoulder.y) / 2.0;
            const verticalDist = shoulderAvgY - nose.y;
            const normalizedDist = verticalDist / shoulderWidth;
            
            if (baselineNoseShoulderDist === null) {
                baselineNoseShoulderDist = normalizedDist;
            }
            
            const deviation = baselineNoseShoulderDist - normalizedDist;
            const slouchScore = Math.max(0, Math.min(1, deviation / 0.15));
            const isSlouching = slouchScore > 0.5;
            
            // 3. Arms crossed detection
            const midlineX = (leftShoulder.x + rightShoulder.x) / 2.0;
            const hipY = (leftHip.y + rightHip.y) / 2.0;
            
            const lwToRs = Math.hypot(leftWrist.x - rightShoulder.x, leftWrist.y - rightShoulder.y);
            const rwToLs = Math.hypot(rightWrist.x - leftShoulder.x, rightWrist.y - leftShoulder.y);
            const lwToLs = Math.hypot(leftWrist.x - leftShoulder.x, leftWrist.y - leftShoulder.y);
            const rwToRs = Math.hypot(rightWrist.x - rightShoulder.x, rightWrist.y - rightShoulder.y);
            
            const lwCenterDist = Math.hypot(leftWrist.x - midlineX, leftWrist.y - shoulderAvgY);
            const rwCenterDist = Math.hypot(rightWrist.x - midlineX, rightWrist.y - shoulderAvgY);
            
            const wristsInward = (lwCenterDist < 0.25 && rwCenterDist < 0.25);
            const wristsUp = (leftWrist.y < hipY && rightWrist.y < hipY);
            const crossed = (lwToRs < lwToLs && rwToLs < rwToRs && wristsInward && wristsUp);
            
            armsCrossedHistory.push(crossed);
            if (armsCrossedHistory.length > 10) armsCrossedHistory.shift();
            const armsCrossed = armsCrossedHistory.filter(x => x).length >= 7;
            
            return {
                shoulder_angle: shoulderAngle,
                is_leaning: isLeaning,
                is_slouching: isSlouching,
                slouch_score: slouchScore,
                arms_crossed: armsCrossed
            };
        }
        
        function updatePostureUI(metrics) {
            if (!metrics) {
                document.getElementById('shoulder-score').innerText = "--";
                document.getElementById('slouch-score').innerText = "--";
                document.getElementById('arms-score').innerText = "--";
                return;
            }
            
            // Shoulder
            const shoulderText = metrics.is_leaning ? 
                `${metrics.shoulder_angle.toFixed(1)}¬∞ ‚ö†Ô∏è LEANING` : 
                `${metrics.shoulder_angle.toFixed(1)}¬∞ ‚úì`;
            document.getElementById('shoulder-score').innerText = shoulderText;
            document.getElementById('shoulder-score').style.color = metrics.is_leaning ? '#ff4444' : '#4CAF50';
            
            // Slouch
            const slouchText = metrics.is_slouching ? 
                `‚ö†Ô∏è SLOUCHING (${(metrics.slouch_score * 100).toFixed(0)}%)` : 
                '‚úì Good';
            document.getElementById('slouch-score').innerText = slouchText;
            document.getElementById('slouch-score').style.color = metrics.is_slouching ? '#ff4444' : '#4CAF50';
            
            // Arms
            const armsText = metrics.arms_crossed ? '‚ùå CROSSED' : '‚úì Open';
            document.getElementById('arms-score').innerText = armsText;
            document.getElementById('arms-score').style.color = metrics.arms_crossed ? '#ff4444' : '#4CAF50';
        }
        
        // NEW: GESTURE ANALYSIS FUNCTIONS
        function calculateDistance(point1, point2) {
            if (!point1 || !point2) return Infinity;
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) + 
                Math.pow(point1.y - point2.y, 2)
            );
        }
        
        function analyzeGestures(leftHandLandmarks, rightHandLandmarks, noseLandmark, shoulderY) {
            const currentTime = Date.now();
            
            // DEBUG: Log what we're receiving
            console.log('Gesture Analysis Debug:', {
                leftHand: leftHandLandmarks ? `${leftHandLandmarks.length} landmarks` : 'null',
                rightHand: rightHandLandmarks ? `${rightHandLandmarks.length} landmarks` : 'null',
                nose: noseLandmark ? 'detected' : 'null',
                shoulderY: shoulderY
            });
            
            // Check hand visibility
            const leftHandVisible = leftHandLandmarks && leftHandLandmarks.length > 0;
            const rightHandVisible = rightHandLandmarks && rightHandLandmarks.length > 0;
            
            console.log('Hand visibility:', { leftHandVisible, rightHandVisible });
            
            // Face-touch detection
            let faceTouchDetected = false;
            
            // Check left hand index finger (landmark 8) to nose distance
            if (leftHandVisible && noseLandmark && leftHandLandmarks[8]) {
                const distance = calculateDistance(leftHandLandmarks[8], noseLandmark);
                console.log('Left hand to nose distance:', distance);
                if (distance < FACE_TOUCH_THRESHOLD) {
                    faceTouchDetected = true;
                    totalFaceTouches++;
                    console.log('LEFT HAND FACE TOUCH DETECTED!');
                }
            }
            
            // Check right hand index finger (landmark 8) to nose distance
            if (rightHandVisible && noseLandmark && rightHandLandmarks[8]) {
                const distance = calculateDistance(rightHandLandmarks[8], noseLandmark);
                console.log('Right hand to nose distance:', distance);
                if (distance < FACE_TOUCH_THRESHOLD) {
                    faceTouchDetected = true;
                    totalFaceTouches++;
                    console.log('RIGHT HAND FACE TOUCH DETECTED!');
                }
            }
            
            // Gesture counting (hands above shoulders with movement)
            let activeGestures = 0;
            let leftAboveShoulders = false;
            let rightAboveShoulders = false;
            
            // Analyze left hand
            if (leftHandVisible && leftHandLandmarks[0]) {
                const wrist = leftHandLandmarks[0];
                console.log('Left wrist Y:', wrist.y, 'Shoulder Y:', shoulderY, 'Threshold:', shoulderY - GESTURE_HEIGHT_THRESHOLD);
                
                if (wrist.y < (shoulderY - GESTURE_HEIGHT_THRESHOLD)) {
                    leftAboveShoulders = true;
                    console.log('Left hand above shoulders!');
                    
                    // Track movement
                    leftHandHistory.push({x: wrist.x, y: wrist.y, time: currentTime});
                    if (leftHandHistory.length > 5) leftHandHistory.shift();
                    
                    // Calculate movement velocity
                    if (leftHandHistory.length >= 3) {
                        let totalMovement = 0;
                        for (let i = 1; i < leftHandHistory.length; i++) {
                            const prev = leftHandHistory[i-1];
                            const curr = leftHandHistory[i];
                            const movement = Math.sqrt(
                                Math.pow(curr.x - prev.x, 2) + 
                                Math.pow(curr.y - prev.y, 2)
                            );
                            totalMovement += movement;
                        }
                        
                        console.log('Left hand movement:', totalMovement);
                        if (totalMovement > GESTURE_VELOCITY_THRESHOLD) {
                            activeGestures++;
                            totalGestures++;
                            gestureTimestamps.push(currentTime);
                            console.log('Left hand gesture detected!');
                        }
                    }
                }
            }
            
            // Analyze right hand (same logic)
            if (rightHandVisible && rightHandLandmarks[0]) {
                const wrist = rightHandLandmarks[0];
                console.log('Right wrist Y:', wrist.y, 'Shoulder Y:', shoulderY, 'Threshold:', shoulderY - GESTURE_HEIGHT_THRESHOLD);
                
                if (wrist.y < (shoulderY - GESTURE_HEIGHT_THRESHOLD)) {
                    rightAboveShoulders = true;
                    console.log('Right hand above shoulders!');
                    
                    // Track movement
                    rightHandHistory.push({x: wrist.x, y: wrist.y, time: currentTime});
                    if (rightHandHistory.length > 5) rightHandHistory.shift();
                    
                    // Calculate movement velocity
                    if (rightHandHistory.length >= 3) {
                        let totalMovement = 0;
                        for (let i = 1; i < rightHandHistory.length; i++) {
                            const prev = rightHandHistory[i-1];
                            const curr = rightHandHistory[i];
                            const movement = Math.sqrt(
                                Math.pow(curr.x - prev.x, 2) + 
                                Math.pow(curr.y - prev.y, 2)
                            );
                            totalMovement += movement;
                        }
                        
                        console.log('Right hand movement:', totalMovement);
                        if (totalMovement > GESTURE_VELOCITY_THRESHOLD) {
                            activeGestures++;
                            totalGestures++;
                            gestureTimestamps.push(currentTime);
                            console.log('Right hand gesture detected!');
                        }
                    }
                }
            }
            
            // Calculate gesture frequency
            const sessionDurationMinutes = (currentTime - gestureSessionStart) / (1000 * 60);
            const gestureFrequency = sessionDurationMinutes > 0 ? totalGestures / sessionDurationMinutes : 0;
            
            // Classify activity level
            let activityLevel = 'passive';
            if (gestureFrequency >= 15) activityLevel = 'dynamic';
            else if (gestureFrequency >= 5) activityLevel = 'moderate';
            
            const result = {
                leftHandVisible,
                rightHandVisible,
                faceTouchDetected,
                faceTouchCount: totalFaceTouches,
                activeGestures,
                gestureFrequency,
                activityLevel,
                leftAboveShoulders,
                rightAboveShoulders
            };
            
            console.log('Final gesture result:', result);
            return result;
        }
        
        function updateGestureUI(gestureMetrics) {
            // Hands visible
            const handsText = `L:${gestureMetrics.leftHandVisible ? '‚úì' : '‚úó'} R:${gestureMetrics.rightHandVisible ? '‚úì' : '‚úó'}`;
            document.getElementById('hands-visible').innerText = handsText;
            
            // Face touch
            const faceTouch = gestureMetrics.faceTouchDetected ? 
                `‚ö†Ô∏è TOUCHING (${gestureMetrics.faceTouchCount || 0})` : 
                `‚úì Clear (${gestureMetrics.faceTouchCount || 0})`;
            document.getElementById('face-touch').innerText = faceTouch;
            document.getElementById('face-touch').style.color = gestureMetrics.faceTouchDetected ? '#ff4444' : '#4CAF50';
            
            // Gestures
            const gesturesText = `${gestureMetrics.activeGestures || 0} (${(gestureMetrics.gestureFrequency || 0).toFixed(1)}/min)`;
            document.getElementById('gestures').innerText = gesturesText;
            
            // Activity level
            const activityText = gestureMetrics.activityLevel || 'passive';
            document.getElementById('activity-level').innerText = activityText.toUpperCase();
            
            // Color code activity level
            const activityColors = {
                'passive': '#888888',
                'moderate': '#FFA500',
                'dynamic': '#FF6B6B'
            };
            document.getElementById('activity-level').style.color = activityColors[activityText] || '#888888';
        }

        // Initialize MediaPipe models
        console.log("üöÄ Initializing MediaPipe Holistic...");
        
        // Holistic (Face + Pose + Hands all in one!)
        const holistic = new Holistic({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
        });
        holistic.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            refineFaceLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        holistic.onResults(onHolisticResults);

        // Camera
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await holistic.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        camera.start().then(() => {
            document.getElementById('status').innerText = "üì∑ Camera started - Loading Holistic model...";
        }).catch((error) => {
            document.getElementById('status').innerText = "‚ùå Camera failed: " + error.message;
            console.error("Camera error:", error);
        });
    </script>
</body>
</html>