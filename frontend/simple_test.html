<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Posture Test</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; text-align: center; }
        .container { position: relative; width: 640px; height: 480px; margin: 20px auto; border: 3px solid #333; }
        #input_video { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        .metrics { margin: 20px; padding: 20px; background: #2d2d2d; border-radius: 8px; }
        .metric { margin: 10px 0; font-size: 18px; }
        .status { margin: 10px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>ü§ñ Simple Posture Test</h1>
    <div class="status" id="status">Initializing...</div>
    
    <div class="container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>
    </div>
    
    <div class="metrics">
        <div class="metric">üëÄ Eye Contact: <span id="eye-score">--</span></div>
        <div class="metric">üìê Shoulder: <span id="shoulder-score">--</span></div>
        <div class="metric">üßç Slouch: <span id="slouch-score">--</span></div>
        <div class="metric">ü§û Arms: <span id="arms-score">--</span></div>
        <hr style="border-color: #555; margin: 15px 0;">
        <div style="color: #FF6B6B; font-weight: bold;">üñêÔ∏è GESTURE ANALYSIS (NEW!)</div>
        <div class="metric">üëã Hands Visible: <span id="hands-visible">--</span></div>
        <div class="metric">üò∞ Face Touch: <span id="face-touch">--</span></div>
        <div class="metric">üé≠ Gestures: <span id="gestures">--</span></div>
        <div class="metric">üìä Activity: <span id="activity-level">--</span></div>
        <hr style="border-color: #555; margin: 15px 0;">
        <div style="color: #FF9500; font-weight: bold;">üß† STRESS ANALYSIS (NEW!)</div>
        <div class="metric">üëÅÔ∏è Blink Rate: <span id="blink-rate">--</span></div>
        <div class="metric">üò∞ Stress Level: <span id="stress-level">--</span></div>
        <div class="metric">üíã Lip Pursing: <span id="lip-pursing">--</span></div>
        <div class="metric">üß† Cognitive Load: <span id="cognitive-load">--</span></div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        let currentLandmarks = null;
        let currentPoseLandmarks = null;
        
        // Your posture analysis variables
        let shoulderHistory = [];
        let baselineNoseShoulderDist = null;
        let armsCrossedHistory = [];
        
        // NEW: Gesture analysis variables
        let gestureSessionStart = Date.now();
        let totalFaceTouches = 0;
        let totalGestures = 0;
        let leftHandHistory = [];
        let rightHandHistory = [];
        let gestureTimestamps = [];
        
        // Gesture analysis thresholds
        const FACE_TOUCH_THRESHOLD = 0.1;
        const GESTURE_HEIGHT_THRESHOLD = 0.1;
        const GESTURE_VELOCITY_THRESHOLD = 0.02;
        
        function onFaceResults(results) {
            // Face mesh results handled in holistic
        }
        
        function onHolisticResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            // Store face landmarks
            if (results.faceLandmarks) {
                currentLandmarks = results.faceLandmarks;
                
                // Draw face mesh
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
                
                // Eye contact calculation
                const leftInner = results.faceLandmarks[33];
                const leftOuter = results.faceLandmarks[133];
                const eyeWidth = Math.abs(leftInner.x - leftOuter.x);
                const leftIris = results.faceLandmarks[468] || leftInner;
                const eyeCenterDist = Math.abs(leftIris.x - ((leftInner.x + leftOuter.x) / 2));
                const eyeContact = Math.max(0, 1.0 - (eyeCenterDist / eyeWidth)).toFixed(2);
                document.getElementById('eye-score').innerText = eyeContact;
            }
            
            // Draw pose skeleton and analyze posture
            if (results.poseLandmarks) {
                currentPoseLandmarks = results.poseLandmarks;
                
                // Draw pose skeleton
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                
                // Draw key points
                const keyPoints = [0, 11, 12, 15, 16, 23, 24];
                keyPoints.forEach(i => {
                    if (results.poseLandmarks[i] && results.poseLandmarks[i].visibility > 0.5) {
                        const lm = results.poseLandmarks[i];
                        let color = '#00FF00';
                        let radius = 5;
                        
                        if (i === 0) { color = '#FF0000'; radius = 6; }  // Nose
                        if (i === 11 || i === 12) { color = '#FFFF00'; radius = 6; }  // Shoulders
                        if (i === 15 || i === 16) { color = '#FF00FF'; radius = 6; }  // Wrists
                        if (i === 23 || i === 24) { color = '#00FFFF'; radius = 5; }  // Hips
                        
                        canvasCtx.fillStyle = color;
                        canvasCtx.beginPath();
                        canvasCtx.arc(lm.x * canvasElement.width, lm.y * canvasElement.height, radius, 0, 2 * Math.PI);
                        canvasCtx.fill();
                        
                        canvasCtx.strokeStyle = '#FFFFFF';
                        canvasCtx.lineWidth = 2;
                        canvasCtx.stroke();
                    }
                });
                
                // YOUR POSTURE ANALYSIS
                const postureMetrics = analyzePosture(results.poseLandmarks);
                updatePostureUI(postureMetrics);
            }
            
            // NEW: Draw hand landmarks if available
            if (results.leftHandLandmarks) {
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#FF00FF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.leftHandLandmarks, {color: '#FF00FF', radius: 3});
            }
            
            if (results.rightHandLandmarks) {
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.rightHandLandmarks, {color: '#00FFFF', radius: 3});
            }
            
            // NEW: Analyze hand gestures
            const gestureMetrics = analyzeGestures(
                results.leftHandLandmarks,
                results.rightHandLandmarks,
                results.faceLandmarks ? results.faceLandmarks[1] : null, // Nose landmark
                results.poseLandmarks ? (results.poseLandmarks[11].y + results.poseLandmarks[12].y) / 2 : 0.5
            );
            updateGestureUI(gestureMetrics);
            
            // NEW: Analyze stress signals
            const stressMetrics = analyzeStress(results.faceLandmarks);
            updateStressUI(stressMetrics);
            
            // Update status
            let statusParts = [];
            if (results.faceLandmarks) statusParts.push("Face");
            if (results.poseLandmarks) statusParts.push("Pose");
            if (results.leftHandLandmarks) statusParts.push("L-Hand");
            if (results.rightHandLandmarks) statusParts.push("R-Hand");
            
            if (statusParts.length > 0) {
                document.getElementById('status').innerText = `‚úÖ Tracking: ${statusParts.join(', ')}`;
            } else {
                document.getElementById('status').innerText = "‚ö†Ô∏è No detection - step back";
            }
            
            canvasCtx.restore();
        }
        
        // YOUR POSTURE ANALYSIS FUNCTION
        function analyzePosture(poseLandmarks) {
            if (!poseLandmarks || poseLandmarks.length < 33) {
                return null;
            }
            
            const nose = poseLandmarks[0];
            const leftShoulder = poseLandmarks[11];
            const rightShoulder = poseLandmarks[12];
            const leftWrist = poseLandmarks[15];
            const rightWrist = poseLandmarks[16];
            const leftHip = poseLandmarks[23];
            const rightHip = poseLandmarks[24];
            
            // 1. Shoulder angle
            const dx = rightShoulder.x - leftShoulder.x;
            const dy = rightShoulder.y - leftShoulder.y;
            let shoulderAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            if (shoulderAngle > 90) shoulderAngle = 180 - shoulderAngle;
            else if (shoulderAngle < -90) shoulderAngle = -180 - shoulderAngle;
            
            const isLeaning = Math.abs(shoulderAngle) > 15.0;
            
            // 2. Slouch detection
            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
            const shoulderAvgY = (leftShoulder.y + rightShoulder.y) / 2.0;
            const verticalDist = shoulderAvgY - nose.y;
            const normalizedDist = verticalDist / shoulderWidth;
            
            if (baselineNoseShoulderDist === null) {
                baselineNoseShoulderDist = normalizedDist;
            }
            
            const deviation = baselineNoseShoulderDist - normalizedDist;
            const slouchScore = Math.max(0, Math.min(1, deviation / 0.15));
            const isSlouching = slouchScore > 0.5;
            
            // 3. Arms crossed detection
            const midlineX = (leftShoulder.x + rightShoulder.x) / 2.0;
            const hipY = (leftHip.y + rightHip.y) / 2.0;
            
            const lwToRs = Math.hypot(leftWrist.x - rightShoulder.x, leftWrist.y - rightShoulder.y);
            const rwToLs = Math.hypot(rightWrist.x - leftShoulder.x, rightWrist.y - leftShoulder.y);
            const lwToLs = Math.hypot(leftWrist.x - leftShoulder.x, leftWrist.y - leftShoulder.y);
            const rwToRs = Math.hypot(rightWrist.x - rightShoulder.x, rightWrist.y - rightShoulder.y);
            
            const lwCenterDist = Math.hypot(leftWrist.x - midlineX, leftWrist.y - shoulderAvgY);
            const rwCenterDist = Math.hypot(rightWrist.x - midlineX, rightWrist.y - shoulderAvgY);
            
            const wristsInward = (lwCenterDist < 0.25 && rwCenterDist < 0.25);
            const wristsUp = (leftWrist.y < hipY && rightWrist.y < hipY);
            const crossed = (lwToRs < lwToLs && rwToLs < rwToRs && wristsInward && wristsUp);
            
            armsCrossedHistory.push(crossed);
            if (armsCrossedHistory.length > 10) armsCrossedHistory.shift();
            const armsCrossed = armsCrossedHistory.filter(x => x).length >= 7;
            
            return {
                shoulder_angle: shoulderAngle,
                is_leaning: isLeaning,
                is_slouching: isSlouching,
                slouch_score: slouchScore,
                arms_crossed: armsCrossed
            };
        }
        
        function updatePostureUI(metrics) {
            if (!metrics) {
                document.getElementById('shoulder-score').innerText = "--";
                document.getElementById('slouch-score').innerText = "--";
                document.getElementById('arms-score').innerText = "--";
                return;
            }
            
            // Shoulder
            const shoulderText = metrics.is_leaning ? 
                `${metrics.shoulder_angle.toFixed(1)}¬∞ ‚ö†Ô∏è LEANING` : 
                `${metrics.shoulder_angle.toFixed(1)}¬∞ ‚úì`;
            document.getElementById('shoulder-score').innerText = shoulderText;
            document.getElementById('shoulder-score').style.color = metrics.is_leaning ? '#ff4444' : '#4CAF50';
            
            // Slouch
            const slouchText = metrics.is_slouching ? 
                `‚ö†Ô∏è SLOUCHING (${(metrics.slouch_score * 100).toFixed(0)}%)` : 
                '‚úì Good';
            document.getElementById('slouch-score').innerText = slouchText;
            document.getElementById('slouch-score').style.color = metrics.is_slouching ? '#ff4444' : '#4CAF50';
            
            // Arms
            const armsText = metrics.arms_crossed ? '‚ùå CROSSED' : '‚úì Open';
            document.getElementById('arms-score').innerText = armsText;
            document.getElementById('arms-score').style.color = metrics.arms_crossed ? '#ff4444' : '#4CAF50';
        }
        
        // NEW: GESTURE ANALYSIS FUNCTIONS
        function calculateDistance(point1, point2) {
            if (!point1 || !point2) return Infinity;
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) + 
                Math.pow(point1.y - point2.y, 2)
            );
        }
        
        function analyzeGestures(leftHandLandmarks, rightHandLandmarks, noseLandmark, shoulderY) {
            const currentTime = Date.now();
            
            // DEBUG: Log what we're receiving
            console.log('Gesture Analysis Debug:', {
                leftHand: leftHandLandmarks ? `${leftHandLandmarks.length} landmarks` : 'null',
                rightHand: rightHandLandmarks ? `${rightHandLandmarks.length} landmarks` : 'null',
                nose: noseLandmark ? 'detected' : 'null',
                shoulderY: shoulderY
            });
            
            // Check hand visibility
            const leftHandVisible = leftHandLandmarks && leftHandLandmarks.length > 0;
            const rightHandVisible = rightHandLandmarks && rightHandLandmarks.length > 0;
            
            console.log('Hand visibility:', { leftHandVisible, rightHandVisible });
            
            // Face-touch detection
            let faceTouchDetected = false;
            
            // Check left hand index finger (landmark 8) to nose distance
            if (leftHandVisible && noseLandmark && leftHandLandmarks[8]) {
                const distance = calculateDistance(leftHandLandmarks[8], noseLandmark);
                console.log('Left hand to nose distance:', distance);
                if (distance < FACE_TOUCH_THRESHOLD) {
                    faceTouchDetected = true;
                    totalFaceTouches++;
                    console.log('LEFT HAND FACE TOUCH DETECTED!');
                }
            }
            
            // Check right hand index finger (landmark 8) to nose distance
            if (rightHandVisible && noseLandmark && rightHandLandmarks[8]) {
                const distance = calculateDistance(rightHandLandmarks[8], noseLandmark);
                console.log('Right hand to nose distance:', distance);
                if (distance < FACE_TOUCH_THRESHOLD) {
                    faceTouchDetected = true;
                    totalFaceTouches++;
                    console.log('RIGHT HAND FACE TOUCH DETECTED!');
                }
            }
            
            // Gesture counting (hands above shoulders with movement)
            let activeGestures = 0;
            let leftAboveShoulders = false;
            let rightAboveShoulders = false;
            
            // Analyze left hand
            if (leftHandVisible && leftHandLandmarks[0]) {
                const wrist = leftHandLandmarks[0];
                console.log('Left wrist Y:', wrist.y, 'Shoulder Y:', shoulderY, 'Threshold:', shoulderY - GESTURE_HEIGHT_THRESHOLD);
                
                if (wrist.y < (shoulderY - GESTURE_HEIGHT_THRESHOLD)) {
                    leftAboveShoulders = true;
                    console.log('Left hand above shoulders!');
                    
                    // Track movement
                    leftHandHistory.push({x: wrist.x, y: wrist.y, time: currentTime});
                    if (leftHandHistory.length > 5) leftHandHistory.shift();
                    
                    // Calculate movement velocity
                    if (leftHandHistory.length >= 3) {
                        let totalMovement = 0;
                        for (let i = 1; i < leftHandHistory.length; i++) {
                            const prev = leftHandHistory[i-1];
                            const curr = leftHandHistory[i];
                            const movement = Math.sqrt(
                                Math.pow(curr.x - prev.x, 2) + 
                                Math.pow(curr.y - prev.y, 2)
                            );
                            totalMovement += movement;
                        }
                        
                        console.log('Left hand movement:', totalMovement);
                        if (totalMovement > GESTURE_VELOCITY_THRESHOLD) {
                            activeGestures++;
                            totalGestures++;
                            gestureTimestamps.push(currentTime);
                            console.log('Left hand gesture detected!');
                        }
                    }
                }
            }
            
            // Analyze right hand (same logic)
            if (rightHandVisible && rightHandLandmarks[0]) {
                const wrist = rightHandLandmarks[0];
                console.log('Right wrist Y:', wrist.y, 'Shoulder Y:', shoulderY, 'Threshold:', shoulderY - GESTURE_HEIGHT_THRESHOLD);
                
                if (wrist.y < (shoulderY - GESTURE_HEIGHT_THRESHOLD)) {
                    rightAboveShoulders = true;
                    console.log('Right hand above shoulders!');
                    
                    // Track movement
                    rightHandHistory.push({x: wrist.x, y: wrist.y, time: currentTime});
                    if (rightHandHistory.length > 5) rightHandHistory.shift();
                    
                    // Calculate movement velocity
                    if (rightHandHistory.length >= 3) {
                        let totalMovement = 0;
                        for (let i = 1; i < rightHandHistory.length; i++) {
                            const prev = rightHandHistory[i-1];
                            const curr = rightHandHistory[i];
                            const movement = Math.sqrt(
                                Math.pow(curr.x - prev.x, 2) + 
                                Math.pow(curr.y - prev.y, 2)
                            );
                            totalMovement += movement;
                        }
                        
                        console.log('Right hand movement:', totalMovement);
                        if (totalMovement > GESTURE_VELOCITY_THRESHOLD) {
                            activeGestures++;
                            totalGestures++;
                            gestureTimestamps.push(currentTime);
                            console.log('Right hand gesture detected!');
                        }
                    }
                }
            }
            
            // Calculate gesture frequency
            const sessionDurationMinutes = (currentTime - gestureSessionStart) / (1000 * 60);
            const gestureFrequency = sessionDurationMinutes > 0 ? totalGestures / sessionDurationMinutes : 0;
            
            // Classify activity level
            let activityLevel = 'passive';
            if (gestureFrequency >= 15) activityLevel = 'dynamic';
            else if (gestureFrequency >= 5) activityLevel = 'moderate';
            
            const result = {
                leftHandVisible,
                rightHandVisible,
                faceTouchDetected,
                faceTouchCount: totalFaceTouches,
                activeGestures,
                gestureFrequency,
                activityLevel,
                leftAboveShoulders,
                rightAboveShoulders
            };
            
            console.log('Final gesture result:', result);
            return result;
        }
        
        // NEW: Stress Analysis Function with Distance Adaptation
        let blinkCount = 0;
        let stressSessionStart = Date.now();
        let lastEyeState = 'open';
        let lipPurseStartTime = null;
        let lipPurseDuration = 0;
        let baselineLipDistance = null;
        let lipCalibrationFrames = 0;
        let lipCalibrationSum = 0;
        let baselineEAR = null;
        let earCalibrationFrames = 0;
        let earCalibrationSum = 0;
        let faceSizeHistory = [];
        
        function analyzeStress(faceLandmarks) {
            if (!faceLandmarks || faceLandmarks.length < 468) {
                return {
                    blinkRate: 0,
                    stressLevel: 'low',
                    lipPursing: false,
                    cognitiveLoad: false,
                    leftEAR: 0.5,
                    rightEAR: 0.5,
                    averageEAR: 0.5
                };
            }
            
            const currentTime = Date.now();
            
            // Calculate face size for distance estimation
            function calculateFaceSize(faceLandmarks) {
                // Face width: left temple to right temple
                const leftTemple = faceLandmarks[234];   // Left temple
                const rightTemple = faceLandmarks[454];  // Right temple
                const faceWidth = Math.abs(leftTemple.x - rightTemple.x);
                
                // Face height: forehead to chin
                const forehead = faceLandmarks[10];   // Forehead center
                const chin = faceLandmarks[152];      // Chin center  
                const faceHeight = Math.abs(forehead.y - chin.y);
                
                // Face size is the average of width and height
                const faceSize = (faceWidth + faceHeight) / 2.0;
                
                // Track face size history for stability
                faceSizeHistory.push(faceSize);
                if (faceSizeHistory.length > 30) faceSizeHistory.shift();
                
                return faceSize;
            }
            
            // Get adaptive EAR threshold based on face size
            function getAdaptiveEARThreshold(faceSize) {
                if (faceSizeHistory.length < 5) return 0.2; // Default
                
                const avgFaceSize = faceSizeHistory.reduce((sum, size) => sum + size, 0) / faceSizeHistory.length;
                
                // Adjust threshold based on face size
                if (avgFaceSize < 0.15) return 0.2 * 1.4;      // Very far - more sensitive
                else if (avgFaceSize < 0.25) return 0.2 * 1.2; // Far - more sensitive  
                else if (avgFaceSize > 0.4) return 0.2 * 0.8;  // Very close - less sensitive
                else if (avgFaceSize > 0.3) return 0.2 * 0.9;  // Close - slightly less sensitive
                else return 0.2; // Normal distance
            }
            
            const faceSize = calculateFaceSize(faceLandmarks);
            
            // Calculate Eye Aspect Ratio (EAR) for blink detection
            function calculateEAR(eyeLandmarks) {
                // EAR = (||p2-p6|| + ||p3-p5||) / (2 * ||p1-p4||)
                const p1 = eyeLandmarks[0], p2 = eyeLandmarks[1], p3 = eyeLandmarks[2];
                const p4 = eyeLandmarks[3], p5 = eyeLandmarks[4], p6 = eyeLandmarks[5];
                
                const dist_p2_p6 = Math.sqrt(Math.pow(p2.x - p6.x, 2) + Math.pow(p2.y - p6.y, 2));
                const dist_p3_p5 = Math.sqrt(Math.pow(p3.x - p5.x, 2) + Math.pow(p3.y - p5.y, 2));
                const dist_p1_p4 = Math.sqrt(Math.pow(p1.x - p4.x, 2) + Math.pow(p1.y - p4.y, 2));
                
                if (dist_p1_p4 === 0) return 0.5;
                return (dist_p2_p6 + dist_p3_p5) / (2.0 * dist_p1_p4);
            }
            
            // Left eye landmarks (user's left eye)
            const leftEye = [
                faceLandmarks[33],   // p1 - left corner
                faceLandmarks[160],  // p2 - top
                faceLandmarks[158],  // p3 - top
                faceLandmarks[133],  // p4 - right corner
                faceLandmarks[153],  // p5 - bottom
                faceLandmarks[144]   // p6 - bottom
            ];
            
            // Right eye landmarks (user's right eye)
            const rightEye = [
                faceLandmarks[362],  // p1 - right corner
                faceLandmarks[387],  // p2 - top
                faceLandmarks[385],  // p3 - top
                faceLandmarks[263],  // p4 - left corner
                faceLandmarks[380],  // p5 - bottom
                faceLandmarks[373]   // p6 - bottom
            ];
            
            const leftEAR = calculateEAR(leftEye);
            const rightEAR = calculateEAR(rightEye);
            const averageEAR = (leftEAR + rightEAR) / 2.0;
            
            // Establish EAR baseline during calibration
            if (baselineEAR === null && earCalibrationFrames < 60) {
                earCalibrationFrames++;
                earCalibrationSum += averageEAR;
                
                if (earCalibrationFrames >= 60) {
                    baselineEAR = earCalibrationSum / earCalibrationFrames;
                }
            }
            
            // Adaptive blink detection
            let adaptiveThreshold = getAdaptiveEARThreshold(faceSize);
            
            // Use baseline if available (60% of baseline or adaptive threshold, whichever is lower)
            if (baselineEAR !== null) {
                const relativeThreshold = baselineEAR * 0.6;
                adaptiveThreshold = Math.min(adaptiveThreshold, relativeThreshold);
            }
            
            if (averageEAR < adaptiveThreshold && lastEyeState === 'open') {
                blinkCount++;
                lastEyeState = 'closed';
            } else if (averageEAR >= adaptiveThreshold) {
                lastEyeState = 'open';
            }
            
            // Calculate blink rate (blinks per minute)
            const sessionDurationMinutes = (currentTime - stressSessionStart) / (1000 * 60);
            const blinkRate = sessionDurationMinutes > 0 ? blinkCount / sessionDurationMinutes : 0;
            
            // Improved lip opening calculation using multiple landmarks
            function calculateLipOpening(faceLandmarks) {
                // Key lip landmarks for accurate measurement
                const upperInner = [13, 82, 81, 80, 78];  // Upper inner lip
                const lowerInner = [14, 87, 178, 88, 95]; // Lower inner lip
                
                let verticalDistances = [];
                
                // Method 1: Inner lip vertical distances
                for (let i = 0; i < Math.min(upperInner.length, lowerInner.length); i++) {
                    const upperPoint = faceLandmarks[upperInner[i]];
                    const lowerPoint = faceLandmarks[lowerInner[i]];
                    
                    if (upperPoint && lowerPoint) {
                        const distance = Math.abs(upperPoint.y - lowerPoint.y);
                        verticalDistances.push(distance);
                    }
                }
                
                // Method 2: Center lip measurement (most reliable)
                const upperCenter = faceLandmarks[13];  // Cupid's bow center
                const lowerCenter = faceLandmarks[14];  // Lower lip center
                
                if (upperCenter && lowerCenter) {
                    const centerDistance = Math.abs(upperCenter.y - lowerCenter.y);
                    verticalDistances.push(centerDistance * 2); // Weight center more
                }
                
                // Method 3: Lip corner measurements
                const leftUpper = faceLandmarks[61];   // Left upper corner
                const leftLower = faceLandmarks[84];   // Left lower corner
                const rightUpper = faceLandmarks[291]; // Right upper corner
                const rightLower = faceLandmarks[314]; // Right lower corner
                
                if (leftUpper && leftLower) {
                    const leftDistance = Math.abs(leftUpper.y - leftLower.y);
                    verticalDistances.push(leftDistance);
                }
                
                if (rightUpper && rightLower) {
                    const rightDistance = Math.abs(rightUpper.y - rightLower.y);
                    verticalDistances.push(rightDistance);
                }
                
                // Calculate average opening with outlier removal
                if (verticalDistances.length > 2) {
                    // Remove extreme values
                    verticalDistances.sort((a, b) => a - b);
                    // Remove top and bottom 20% to reduce noise
                    const trimCount = Math.max(1, Math.floor(verticalDistances.length / 5));
                    const trimmedDistances = verticalDistances.slice(trimCount, -trimCount);
                    
                    return trimmedDistances.reduce((sum, d) => sum + d, 0) / trimmedDistances.length;
                } else {
                    return verticalDistances.reduce((sum, d) => sum + d, 0) / verticalDistances.length || 0.05;
                }
            }
            
            const lipDistance = calculateLipOpening(faceLandmarks);
            
            let lipPursing = false;
            
            // Establish baseline during first 60 frames (2 seconds at 30fps)
            if (baselineLipDistance === null && lipCalibrationFrames < 60) {
                lipCalibrationFrames++;
                lipCalibrationSum += lipDistance;
                
                if (lipCalibrationFrames >= 60) {
                    baselineLipDistance = lipCalibrationSum / lipCalibrationFrames;
                    console.log('üìè Lip baseline established:', baselineLipDistance.toFixed(4));
                }
            }
            
            // Only detect pursing after baseline is established
            if (baselineLipDistance !== null) {
                const LIP_COMPRESSION_RATIO = 0.7; // 70% of baseline opening
                const compressionThreshold = baselineLipDistance * LIP_COMPRESSION_RATIO;
                
                if (lipDistance < compressionThreshold) {
                    if (lipPurseStartTime === null) {
                        lipPurseStartTime = currentTime;
                    } else {
                        lipPurseDuration = (currentTime - lipPurseStartTime) / 1000;
                        lipPursing = lipPurseDuration >= 2.0; // 2 seconds threshold (was 3.0)
                    }
                } else {
                    lipPurseStartTime = null;
                    lipPurseDuration = 0;
                }
            }
            
            // Cognitive load assessment
            const cognitiveLoad = blinkRate > 30; // 30 blinks per minute threshold
            
            // Overall stress level classification
            let stressLevel = 'low';
            let stressIndicators = 0;
            
            if (blinkRate > 30) stressIndicators += 2;
            else if (blinkRate > 21) stressIndicators += 1; // 70% of threshold
            
            if (lipPursing) stressIndicators += 2;
            
            if (stressIndicators >= 3) stressLevel = 'high';
            else if (stressIndicators >= 1) stressLevel = 'moderate';
            
            return {
                blinkRate: blinkRate,
                blinkCount: blinkCount,
                stressLevel: stressLevel,
                lipPursing: lipPursing,
                lipPurseDuration: lipPurseDuration,
                cognitiveLoad: cognitiveLoad,
                leftEAR: leftEAR,
                rightEAR: rightEAR,
                averageEAR: averageEAR
            };
        }
        
        function updateStressUI(stressMetrics) {
            if (!stressMetrics) {
                document.getElementById('blink-rate').innerText = "--";
                document.getElementById('stress-level').innerText = "--";
                document.getElementById('lip-pursing').innerText = "--";
                document.getElementById('cognitive-load').innerText = "--";
                return;
            }
            
            // Blink rate
            let blinkText;
            if (baselineEAR === null) {
                blinkText = `üëÅÔ∏è Calibrating... (${earCalibrationFrames}/60)`;
            } else {
                blinkText = `${stressMetrics.blinkRate.toFixed(1)}/min (${stressMetrics.blinkCount})`;
            }
            document.getElementById('blink-rate').innerText = blinkText;
            document.getElementById('blink-rate').style.color = 
                baselineEAR === null ? '#FFA500' : 
                (stressMetrics.blinkRate > 30 ? '#ff4444' : '#4CAF50');
            
            // Stress level
            const stressText = stressMetrics.stressLevel.toUpperCase();
            document.getElementById('stress-level').innerText = stressText;
            const stressColors = {
                'LOW': '#4CAF50',
                'MODERATE': '#FFA500',
                'HIGH': '#ff4444'
            };
            document.getElementById('stress-level').style.color = stressColors[stressText] || '#888888';
            
            // Lip pursing
            let lipText;
            if (baselineLipDistance === null) {
                lipText = `üìè Calibrating... (${lipCalibrationFrames}/60)`;
            } else if (stressMetrics.lipPursing) {
                lipText = `‚ö†Ô∏è PURSING (${stressMetrics.lipPurseDuration.toFixed(1)}s)`;
            } else if (lipPurseDuration > 0) {
                lipText = `ü§è Compressing (${lipPurseDuration.toFixed(1)}s)`;
            } else {
                lipText = '‚úì Relaxed';
            }
            document.getElementById('lip-pursing').innerText = lipText;
            document.getElementById('lip-pursing').style.color = 
                baselineLipDistance === null ? '#FFA500' : 
                (stressMetrics.lipPursing ? '#ff4444' : 
                 (lipPurseDuration > 0 ? '#FFA500' : '#4CAF50'));
            
            // Cognitive load
            const cognitiveText = stressMetrics.cognitiveLoad ? '‚ö†Ô∏è HIGH' : '‚úì Normal';
            document.getElementById('cognitive-load').innerText = cognitiveText;
            document.getElementById('cognitive-load').style.color = stressMetrics.cognitiveLoad ? '#ff4444' : '#4CAF50';
        }
        
        function updateGestureUI(gestureMetrics) {
            // Hands visible
            const handsText = `L:${gestureMetrics.leftHandVisible ? '‚úì' : '‚úó'} R:${gestureMetrics.rightHandVisible ? '‚úì' : '‚úó'}`;
            document.getElementById('hands-visible').innerText = handsText;
            
            // Face touch
            const faceTouch = gestureMetrics.faceTouchDetected ? 
                `‚ö†Ô∏è TOUCHING (${gestureMetrics.faceTouchCount || 0})` : 
                `‚úì Clear (${gestureMetrics.faceTouchCount || 0})`;
            document.getElementById('face-touch').innerText = faceTouch;
            document.getElementById('face-touch').style.color = gestureMetrics.faceTouchDetected ? '#ff4444' : '#4CAF50';
            
            // Gestures
            const gesturesText = `${gestureMetrics.activeGestures || 0} (${(gestureMetrics.gestureFrequency || 0).toFixed(1)}/min)`;
            document.getElementById('gestures').innerText = gesturesText;
            
            // Activity level
            const activityText = gestureMetrics.activityLevel || 'passive';
            document.getElementById('activity-level').innerText = activityText.toUpperCase();
            
            // Color code activity level
            const activityColors = {
                'passive': '#888888',
                'moderate': '#FFA500',
                'dynamic': '#FF6B6B'
            };
            document.getElementById('activity-level').style.color = activityColors[activityText] || '#888888';
        }

        // Initialize MediaPipe models
        console.log("üöÄ Initializing MediaPipe Holistic...");
        
        // Holistic (Face + Pose + Hands all in one!)
        const holistic = new Holistic({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
        });
        holistic.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            refineFaceLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        holistic.onResults(onHolisticResults);

        // Camera
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await holistic.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        camera.start().then(() => {
            document.getElementById('status').innerText = "üì∑ Camera started - Loading Holistic model...";
        }).catch((error) => {
            document.getElementById('status').innerText = "‚ùå Camera failed: " + error.message;
            console.error("Camera error:", error);
        });
    </script>
</body>
</html>