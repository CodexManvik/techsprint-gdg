<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Posture Test</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; text-align: center; }
        .container { position: relative; width: 640px; height: 480px; margin: 20px auto; border: 3px solid #333; }
        #input_video { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        .metrics { margin: 20px; padding: 20px; background: #2d2d2d; border-radius: 8px; }
        .metric { margin: 10px 0; font-size: 18px; }
        .status { margin: 10px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>ü§ñ Simple Posture Test</h1>
    <div class="status" id="status">Initializing...</div>
    
    <div class="container">
        <video id="input_video"></video>
        <canvas id="output_canvas"></canvas>
    </div>
    
    <div class="metrics">
        <div class="metric">üëÄ Eye Contact: <span id="eye-score">--</span></div>
        <div class="metric">üìê Shoulder: <span id="shoulder-score">--</span></div>
        <div class="metric">üßç Slouch: <span id="slouch-score">--</span></div>
        <div class="metric">ü§û Arms: <span id="arms-score">--</span></div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        let currentLandmarks = null;
        let currentPoseLandmarks = null;
        
        // Your posture analysis variables
        let shoulderHistory = [];
        let baselineNoseShoulderDist = null;
        let armsCrossedHistory = [];
        
        function onFaceResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                currentLandmarks = results.multiFaceLandmarks[0];
            }
        }
        
        function onPoseResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            // Draw face mesh if available
            if (currentLandmarks) {
                drawConnectors(canvasCtx, currentLandmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
                drawConnectors(canvasCtx, currentLandmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
                drawConnectors(canvasCtx, currentLandmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
                
                // Eye contact calculation
                const leftInner = currentLandmarks[33];
                const leftOuter = currentLandmarks[133];
                const eyeWidth = Math.abs(leftInner.x - leftOuter.x);
                const leftIris = currentLandmarks[468] || leftInner;
                const eyeCenterDist = Math.abs(leftIris.x - ((leftInner.x + leftOuter.x) / 2));
                const eyeContact = Math.max(0, 1.0 - (eyeCenterDist / eyeWidth)).toFixed(2);
                document.getElementById('eye-score').innerText = eyeContact;
            }
            
            // Draw pose skeleton and analyze posture
            if (results.poseLandmarks) {
                currentPoseLandmarks = results.poseLandmarks;
                
                // Draw pose skeleton
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                
                // Draw key points
                const keyPoints = [0, 11, 12, 15, 16, 23, 24];
                keyPoints.forEach(i => {
                    if (results.poseLandmarks[i] && results.poseLandmarks[i].visibility > 0.5) {
                        const lm = results.poseLandmarks[i];
                        let color = '#00FF00';
                        let radius = 5;
                        
                        if (i === 0) { color = '#FF0000'; radius = 6; }  // Nose
                        if (i === 11 || i === 12) { color = '#FFFF00'; radius = 6; }  // Shoulders
                        if (i === 15 || i === 16) { color = '#FF00FF'; radius = 6; }  // Wrists
                        if (i === 23 || i === 24) { color = '#00FFFF'; radius = 5; }  // Hips
                        
                        canvasCtx.fillStyle = color;
                        canvasCtx.beginPath();
                        canvasCtx.arc(lm.x * canvasElement.width, lm.y * canvasElement.height, radius, 0, 2 * Math.PI);
                        canvasCtx.fill();
                        
                        canvasCtx.strokeStyle = '#FFFFFF';
                        canvasCtx.lineWidth = 2;
                        canvasCtx.stroke();
                    }
                });
                
                // YOUR POSTURE ANALYSIS
                const postureMetrics = analyzePosture(results.poseLandmarks);
                updatePostureUI(postureMetrics);
                
                document.getElementById('status').innerText = "‚úÖ Full Body Tracking Active";
            } else if (currentLandmarks) {
                document.getElementById('status').innerText = "‚úÖ Face Only - Step back for full body";
            } else {
                document.getElementById('status').innerText = "‚ö†Ô∏è No detection";
            }
            
            canvasCtx.restore();
        }
        
        // YOUR POSTURE ANALYSIS FUNCTION
        function analyzePosture(poseLandmarks) {
            if (!poseLandmarks || poseLandmarks.length < 33) {
                return null;
            }
            
            const nose = poseLandmarks[0];
            const leftShoulder = poseLandmarks[11];
            const rightShoulder = poseLandmarks[12];
            const leftWrist = poseLandmarks[15];
            const rightWrist = poseLandmarks[16];
            const leftHip = poseLandmarks[23];
            const rightHip = poseLandmarks[24];
            
            // 1. Shoulder angle
            const dx = rightShoulder.x - leftShoulder.x;
            const dy = rightShoulder.y - leftShoulder.y;
            let shoulderAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            if (shoulderAngle > 90) shoulderAngle = 180 - shoulderAngle;
            else if (shoulderAngle < -90) shoulderAngle = -180 - shoulderAngle;
            
            const isLeaning = Math.abs(shoulderAngle) > 15.0;
            
            // 2. Slouch detection
            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
            const shoulderAvgY = (leftShoulder.y + rightShoulder.y) / 2.0;
            const verticalDist = shoulderAvgY - nose.y;
            const normalizedDist = verticalDist / shoulderWidth;
            
            if (baselineNoseShoulderDist === null) {
                baselineNoseShoulderDist = normalizedDist;
            }
            
            const deviation = baselineNoseShoulderDist - normalizedDist;
            const slouchScore = Math.max(0, Math.min(1, deviation / 0.15));
            const isSlouching = slouchScore > 0.5;
            
            // 3. Arms crossed detection
            const midlineX = (leftShoulder.x + rightShoulder.x) / 2.0;
            const hipY = (leftHip.y + rightHip.y) / 2.0;
            
            const lwToRs = Math.hypot(leftWrist.x - rightShoulder.x, leftWrist.y - rightShoulder.y);
            const rwToLs = Math.hypot(rightWrist.x - leftShoulder.x, rightWrist.y - leftShoulder.y);
            const lwToLs = Math.hypot(leftWrist.x - leftShoulder.x, leftWrist.y - leftShoulder.y);
            const rwToRs = Math.hypot(rightWrist.x - rightShoulder.x, rightWrist.y - rightShoulder.y);
            
            const lwCenterDist = Math.hypot(leftWrist.x - midlineX, leftWrist.y - shoulderAvgY);
            const rwCenterDist = Math.hypot(rightWrist.x - midlineX, rightWrist.y - shoulderAvgY);
            
            const wristsInward = (lwCenterDist < 0.25 && rwCenterDist < 0.25);
            const wristsUp = (leftWrist.y < hipY && rightWrist.y < hipY);
            const crossed = (lwToRs < lwToLs && rwToLs < rwToRs && wristsInward && wristsUp);
            
            armsCrossedHistory.push(crossed);
            if (armsCrossedHistory.length > 10) armsCrossedHistory.shift();
            const armsCrossed = armsCrossedHistory.filter(x => x).length >= 7;
            
            return {
                shoulder_angle: shoulderAngle,
                is_leaning: isLeaning,
                is_slouching: isSlouching,
                slouch_score: slouchScore,
                arms_crossed: armsCrossed
            };
        }
        
        function updatePostureUI(metrics) {
            if (!metrics) {
                document.getElementById('shoulder-score').innerText = "--";
                document.getElementById('slouch-score').innerText = "--";
                document.getElementById('arms-score').innerText = "--";
                return;
            }
            
            // Shoulder
            const shoulderText = metrics.is_leaning ? 
                `${metrics.shoulder_angle.toFixed(1)}¬∞ ‚ö†Ô∏è LEANING` : 
                `${metrics.shoulder_angle.toFixed(1)}¬∞ ‚úì`;
            document.getElementById('shoulder-score').innerText = shoulderText;
            document.getElementById('shoulder-score').style.color = metrics.is_leaning ? '#ff4444' : '#4CAF50';
            
            // Slouch
            const slouchText = metrics.is_slouching ? 
                `‚ö†Ô∏è SLOUCHING (${(metrics.slouch_score * 100).toFixed(0)}%)` : 
                '‚úì Good';
            document.getElementById('slouch-score').innerText = slouchText;
            document.getElementById('slouch-score').style.color = metrics.is_slouching ? '#ff4444' : '#4CAF50';
            
            // Arms
            const armsText = metrics.arms_crossed ? '‚ùå CROSSED' : '‚úì Open';
            document.getElementById('arms-score').innerText = armsText;
            document.getElementById('arms-score').style.color = metrics.arms_crossed ? '#ff4444' : '#4CAF50';
        }

        // Initialize MediaPipe models
        console.log("üöÄ Initializing MediaPipe...");
        
        // FaceMesh
        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onFaceResults);
        
        // Pose (YOUR SYSTEM!)
        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
        });
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        pose.onResults(onPoseResults);

        // Camera
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({image: videoElement});
                await pose.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        camera.start().then(() => {
            document.getElementById('status').innerText = "üì∑ Camera started - Loading models...";
        }).catch((error) => {
            document.getElementById('status').innerText = "‚ùå Camera failed: " + error.message;
            console.error("Camera error:", error);
        });
    </script>
</body>
</html>